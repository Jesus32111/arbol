<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Árbol de Corazones</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: linear-gradient(to bottom, #9fd6dc 0%, #f5e4c3 70%);
    overflow: hidden;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  canvas {
    display: block;
    transition: transform 3s ease-in-out; /* movimiento suave a la derecha */
  }

  /* Contenedor de botones */
  .button-container {
    position: absolute;
    left: 30px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 15px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 1.2s ease;
  }

  .button-container.show {
    opacity: 1;
    pointer-events: auto;
  }

  .button-container button {
    background-color: #ff5c8a;
    border: none;
    color: white;
    padding: 12px 18px;
    font-size: 16px;
    border-radius: 25px;
    cursor: pointer;
    transition: transform 0.2s, background 0.3s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
  }

  .button-container button:hover {
    background-color: #ff85a2;
    transform: scale(1.08);
  }

  /* ======= Frase Caja (añadida) ======= */
  .frase-box {
    position: absolute;
    left: 300px; /* separada de los botones */
    top: 30%;
    transform: translateY(-50%);
    max-width: 600px;
    min-width: 400px;
    padding: 18px 20px;
    border-radius: 14px;
    background: rgba(255,255,255,0.06);
    backdrop-filter: blur(6px);
    color: #ff516f;
    font-weight: 600;
    line-height: 1.35;
    font-size: 60px;
    opacity: 0;
    transition: opacity 0.5s ease, transform 0.35s ease;
    pointer-events: none;
    display: flex;
    align-items: center;
  }

  .frase-box.show {
    opacity: 1;
    pointer-events: auto;
  }

  .frase-text {
    display: inline-block;
    vertical-align: middle;
    text-align: center;
    font-family: "Poppins", sans-serif;
    color: #ff2f61;
  }

  .frase-cursor {
    display: inline-block;
    width: 8px;
    height: 26px;
    margin-left: 8px;
    background: #ff2f61;
    border-radius: 3px;
    vertical-align: bottom;
    animation: blink 0.8s steps(1) infinite;
  }

  @keyframes blink {
    50% { opacity: 0; }
  }

  /* Pequeña responsividad */
  @media (max-width: 900px) {
    .frase-box { left: 80px; font-size: 18px; max-width: 320px; }
  }
</style>
</head>
<body>
<canvas id="tree"></canvas>

<!-- Botones ocultos hasta el final -->
<div class="button-container" id="buttonContainer">
  <button id="btnFrases">Frases Lindas</button>
  <button id="btnCuriosidades">Curiosidades</button>
</div>

<!-- Caja para mostrar las frases (añadida) -->
<div class="frase-box" id="fraseBox" aria-live="polite">
  <div class="frase-text" id="fraseText"></div>
  <div class="frase-cursor" id="fraseCursor" aria-hidden="true"></div>
</div>

<script>
const canvas = document.getElementById("tree");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const baseX = canvas.width / 2;
const baseY = canvas.height * 0.95;
const maxDepth = 9;
const totalGrowTime = 3500;

let branches = [], trunkBranches = [], mainBranches = [], thinBranches = [];
let leaves = [], heartLeaves = [], fallingHearts = [];
let treePath = new Path2D();
let trunkPath = new Path2D();
let startTime = null;

// === GENERACIÓN DEL ÁRBOL ===
function generateTree(x, y, length, angle, depth, width) {
  if (depth === 0) return;
  const endX = x + length * Math.cos(angle);
  const endY = y - length * Math.sin(angle);
  const branch = { x1: x, y1: y, x2: endX, y2: endY, width, depth, level: maxDepth - depth };
  branches.push(branch);
  if (depth === maxDepth) trunkBranches.push(branch);
  else if (depth > 4) mainBranches.push(branch);
  else thinBranches.push(branch);

  const nextLength = length * 0.75;
  const nextWidth = width * 0.7;
  const angleVar = 0.37;
  const rand = (Math.random() - 0.5) * 0.08;
  generateTree(endX, endY, nextLength, angle - angleVar + rand, depth - 1, nextWidth);
  generateTree(endX, endY, nextLength, angle + angleVar + rand, depth - 1, nextWidth);
}

function drawBranch(branch, progress = 1) {
  const dx = branch.x2 - branch.x1;
  const dy = branch.y2 - branch.y1;
  const currentX = branch.x1 + dx * progress;
  const currentY = branch.y1 + dy * progress;
  const grad = ctx.createLinearGradient(branch.x1, branch.y1, currentX, currentY);
  grad.addColorStop(0, "#3a2200");
  grad.addColorStop(1, "#8b5a2b");
  ctx.strokeStyle = grad;
  ctx.lineWidth = Math.max(1, branch.width * (0.8 + progress * 0.2));
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(branch.x1, branch.y1);
  ctx.lineTo(currentX, currentY);
  ctx.stroke();
}

function drawHeart(x, y, size, rotation, color, alpha = 1) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(x, y);
  ctx.rotate(rotation);
  ctx.scale(size / 10, size / 10);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.bezierCurveTo(-5, -5, -10, 0, 0, 10);
  ctx.bezierCurveTo(10, 0, 5, -5, 0, 0);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.restore();
}

function buildTreePath() {
  treePath = new Path2D();
  trunkPath = new Path2D();
  branches.forEach(b => {
    const dx = b.x2 - b.x1;
    const dy = b.y2 - b.y1;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len === 0) return;
    const nx = -dy / len, ny = dx / len;
    let offset = Math.max(b.width / 2, 2);
    const left = [], right = [];
    for (let i = 0; i <= 8; i++) {
      const t = i / 8;
      const px = b.x1 + dx * t, py = b.y1 + dy * t;
      left.push({ x: px + nx * offset, y: py + ny * offset });
      right.push({ x: px - nx * offset, y: py - ny * offset });
    }
    treePath.moveTo(left[0].x, left[0].y);
    left.forEach((p, i) => i > 0 && treePath.lineTo(p.x, p.y));
    for (let i = right.length - 1; i >= 0; i--) treePath.lineTo(right[i].x, right[i].y);
    treePath.closePath();

    if (b.depth === maxDepth) {
      trunkPath.moveTo(left[0].x, left[0].y);
      left.forEach((p, i) => i > 0 && trunkPath.lineTo(p.x, p.y));
      for (let i = right.length - 1; i >= 0; i--) trunkPath.lineTo(right[i].x, right[i].y);
      trunkPath.closePath();
    }
  });
}

function generateLeaves() {
  leaves = [];
  const colors = ["#ff5c8a","#ff6f91","#ff85a2","#ff9ecb","#ffb3d9","#ff7bbf","#ff8bb9","#ff5fa0","#ff99cc"];
  const pending = [];
  function pushLeaf(x, y, size, color, rotation, alpha = 1) {
    pending.push({ x, y, size, color, rotation, grow: 0, alpha });
  }
  function branchLeaves(b) {
    for (let s = 0; s < 3; s++) {
      const t = (s + Math.random()) / 3;
      const px = b.x1 + (b.x2 - b.x1) * t;
      const py = b.y1 + (b.y2 - b.y1) * t;
      const count = b.depth > 4 ? 6 : 3;
      for (let l = 0; l < count; l++) {
        const ang = Math.random() * Math.PI * 2;
        const r = 10 + Math.random() * 20;
        const lx = px + Math.cos(ang) * r;
        const ly = py - Math.sin(ang) * r;
        if (!ctx.isPointInPath(trunkPath, lx, ly))
          pushLeaf(lx, ly, 6 + Math.random() * 10, colors[Math.floor(Math.random() * colors.length)], Math.random() * Math.PI);
      }
    }
  }
  [...thinBranches, ...mainBranches].forEach(branchLeaves);
  let i = 0;
  function addBatch() {
    for (let n = 0; n < 10 && i < pending.length; n++, i++) leaves.push(pending[i]);
    if (i < pending.length) setTimeout(addBatch, 8);
  }
  addBatch();
}

function generateHeartLeaves() {
  heartLeaves = [];
  const colors = ["#ff5c8a", "#ff6f91", "#ff85a2", "#ff9ecb", "#ffb3d9"];
  const count = 2300, scale = 190;
  const centerX = baseX, centerY = canvas.height * 0.26;
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const r = 1 - Math.random() * 0.25;
    const x = 16 * Math.pow(Math.sin(a), 3);
    let y = 13 * Math.cos(a) - 5 * Math.cos(2 * a) - 2 * Math.cos(3 * a) - Math.cos(4 * a);
    if (y < -2) y *= 1.3;
    const finalX = centerX + x * scale * r;
    const finalY = centerY + y * -scale * 0.9 * r;
    if (!ctx.isPointInPath(trunkPath, finalX, finalY))
      heartLeaves.push({
        x: finalX, y: finalY, size: 6 + Math.random() * 10,
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * Math.PI, grow: 0.1, alpha: 1
      });
  }
}

function spawnFallingHeart() {
  if (heartLeaves.length === 0) return;
  const src = heartLeaves[Math.floor(Math.random() * heartLeaves.length)];
  fallingHearts.push({
    x: src.x,
    y: src.y,
    size: src.size,
    color: src.color,
    rotation: Math.random() * Math.PI,
    alpha: 1,
    speedY: 1 + Math.random() * 2,
    sway: 1 + Math.random() * 2,
    swayPhase: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.02
  });
}

function animate() {
  let t = 0;
  setTimeout(() => {
    moveCanvasRight();
  }, 10000);

  function loop() {
    t += 0.02;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    branches.forEach(b => drawBranch(b, 1));

    leaves.forEach(l => {
      if (l.grow < 1) l.grow += 0.03;
      drawHeart(l.x + Math.sin(t + l.x / 50) * 2, l.y + Math.cos(t + l.y / 50) * 2, l.size * l.grow, l.rotation, l.color, l.alpha);
    });

    heartLeaves.forEach(h => {
      if (h.grow < 1) h.grow += 0.04;
      drawHeart(h.x + Math.sin(t + h.x / 25) * 2.5, h.y + Math.cos(t + h.y / 35) * 2.5, h.size * h.grow, h.rotation, h.color, h.alpha);
    });

    if (Math.random() < 3) spawnFallingHeart();

    for (let i = fallingHearts.length - 1; i >= 0; i--) {
      const f = fallingHearts[i];
      f.y += f.speedY;
      f.x += Math.sin(t * f.sway + f.swayPhase);
      f.rotation += f.rotSpeed;
      f.alpha -= 0.002;
      drawHeart(f.x, f.y, f.size, f.rotation, f.color, Math.max(f.alpha, 0));
      if (f.y > canvas.height || f.alpha <= 0) fallingHearts.splice(i, 1);
    }

    requestAnimationFrame(loop);
  }
  loop();
}

function moveCanvasRight() {
  canvas.style.transform = "translateX(400px)";

  // Cuando termine la transición de 3s, mostrar los botones
  canvas.addEventListener("transitionend", () => {
    const buttonContainer = document.getElementById("buttonContainer");
    buttonContainer.classList.add("show");
  }, { once: true });
}

function start() {
  branches = [];
  trunkBranches = [];
  mainBranches = [];
  thinBranches = [];
  leaves = [];
  heartLeaves = [];
  fallingHearts = [];
  startTime = null;

  generateTree(baseX, baseY, 180, Math.PI / 2, maxDepth, 35);
  buildTreePath();
  requestAnimationFrame(grow);
}

function grow(timestamp) {
  if (!startTime) startTime = timestamp;
  const elapsed = timestamp - startTime;
  const progress = Math.min(elapsed / totalGrowTime, 1);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const maxLevel = Math.max(...branches.map(b => b.level));
  const levelDuration = totalGrowTime / (maxLevel + 1);

  branches.forEach(b => {
    const start = b.level * levelDuration;
    if (elapsed >= start) {
      const branchProgress = Math.min((elapsed - start) / (levelDuration * 1.2), 1);
      drawBranch(b, branchProgress);
    }
  });

  if (progress < 1) requestAnimationFrame(grow);
  else {
    generateLeaves();
    generateHeartLeaves();
    setTimeout(animate, 800);
  }
}

start();

/* ===========================
   Código añadido para frases
   =========================== */

/* 30 frases (tema amor moderno, lindas) */
const frases = [
  "Eres mi casualidad más bonita.",
  "Tu sonrisa ilumina mis días más grises.",
  "Amarte es mi forma favorita de pasar el tiempo.",
  "Desde que llegaste, todo tiene sentido.",
  "Tu abrazo es mi lugar seguro.",
  "Eres mi pensamiento favorito.",
  "Te miro y me siento en casa.",
  "El amor eres tú en todas tus formas.",
  "Cada latido me recuerda por qué te elijo.",
  "Tu voz suena como mi melodía favorita.",
  "Contigo, los segundos saben a eternidad.",
  "No busco finales felices, te busco a ti.",
  "Eres mi sueño que no quiero despertar.",
  "Tus ojos tienen el brillo que mi alma buscaba.",
  "Si sonrío sin razón, es por tu culpa.",
  "Tu amor es el color de mi mundo.",
  "Eres la poesía que no sabía que quería leer.",
  "Cada día contigo se siente como magia.",
  "Te pienso, y el corazón me late más bonito.",
  "Eres la calma después de mis tormentas.",
  "No hay distancia para lo que siento por ti.",
  "Eres mi amanecer favorito.",
  "Tenerte cerca es mi definición de felicidad.",
  "Tu risa es mi sonido preferido.",
  "Eres el capítulo más dulce de mi historia.",
  "Si el amor tuviera rostro, sería el tuyo.",
  "Te amo sin pausas ni condiciones.",
  "Eres la casualidad más hermosa que el destino planeó.",
  "Cada día contigo es un pequeño paraíso.",
  "Eres mi lugar favorito en el mundo."
];

/* Pesos/probabilidades iniciales */
let pesos = Array(frases.length).fill(1);

/* Umbral para resetear: cuando todos los pesos estén muy bajos (p.ej. < 0.25) reiniciamos a 1 */
const RESET_THRESHOLD = 0.25;

/* Elementos DOM para frases */
const btnFrases = document.getElementById("btnFrases");
const fraseBox = document.getElementById("fraseBox");
const fraseText = document.getElementById("fraseText");
const fraseCursor = document.getElementById("fraseCursor");

/* Función para elegir frase aleatoria con pesos (preferencia a pesos altos) */
function elegirFrasePorPeso() {
  const total = pesos.reduce((a,b) => a + b, 0);
  let r = Math.random() * total;
  for (let i = 0; i < pesos.length; i++) {
    if (r < pesos[i]) {
      // reducir la probabilidad de esta frase para las siguientes selecciones
      pesos[i] *= 0.22; // reduce bastante la probabilidad de volver a salir pronto
      // si todos los pesos son muy pequeños, resetear
      if (pesos.every(p => p < RESET_THRESHOLD)) {
        pesos = Array(frases.length).fill(1);
      }
      return frases[i];
    }
    r -= pesos[i];
  }
  return frases[0];
}

/* Efecto máquina de escribir (no borra funciones existentes) */
let typingTimeout = null;
function escribirMaquina(texto, speed = 40) {
  // mostrar caja (pero solo si ya se mostró container de botones)
  fraseBox.classList.add("show");
  fraseText.textContent = "";
  fraseCursor.style.display = "inline-block";

  let idx = 0;
  if (typingTimeout) { clearTimeout(typingTimeout); typingTimeout = null; }

  function step() {
    if (idx <= texto.length - 1) {
      // añadir caracter
      fraseText.textContent += texto[idx];
      idx++;
      typingTimeout = setTimeout(step, speed + Math.floor(Math.random() * 30)); // pequeña variación
    } else {
      // terminado, ocultar cursor tras un instante
      fraseCursor.style.display = "none";
    }
  }
  step();
}

/* Mostrar frase al click — solo después de que los botones estén visibles (ese control lo deja el transitionend original) */
btnFrases.addEventListener("click", () => {
  // Si la caja de botones no está visible aún, forzamos su aparición mínima (por seguridad)
  const btnContainer = document.getElementById("buttonContainer");
  if (!btnContainer.classList.contains("show")) {
    btnContainer.classList.add("show");
  }

  // Elegir frase y escribirla
  const frase = elegirFrasePorPeso();
  escribirMaquina(frase, 36); // velocidad 36ms por carácter (ligeramente variable)
});

</script>
</body>
</html>
