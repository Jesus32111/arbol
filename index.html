<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Árbol con Copa Corazón Voluminosa</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: linear-gradient(to bottom, #87CEEB 0%, #f5e4c3 70%);
    overflow: hidden;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: flex-end;
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="tree"></canvas>
<script>
const canvas = document.getElementById("tree");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const baseX = canvas.width / 2;
const baseY = canvas.height * 0.95;
const maxDepth = 9;
const totalGrowTime = 3500;

let trunkBranches = [], mainBranches = [], thinBranches = [];
let branches = [], leaves = [], heartLeaves = [];
let startTime = null;

// === ZONA PROHIBIDA ===
let treePath = new Path2D();
let trunkPath = new Path2D();

// === GENERACIÓN DEL ÁRBOL ===
function generateTree(x, y, length, angle, depth, width) {
  if (depth === 0) return;
  const endX = x + length * Math.cos(angle);
  const endY = y - length * Math.sin(angle);
  const branch = { x1: x, y1: y, x2: endX, y2: endY, width, depth, level: maxDepth - depth };
  branches.push(branch);
  if (depth === maxDepth) trunkBranches.push(branch);
  else if (depth > 4) mainBranches.push(branch);
  else thinBranches.push(branch);

  const nextLength = length * 0.75;
  const nextWidth = width * 0.7;
  const fixedAngle = 0.37;
  const rand = (Math.random() - 0.5) * 0.08;
  generateTree(endX, endY, nextLength, angle - fixedAngle + rand, depth - 1, nextWidth);
  generateTree(endX, endY, nextLength, angle + fixedAngle + rand, depth - 1, nextWidth);
}

// === DIBUJO DE RAMAS ===
function drawBranch(branch, progress = 1) {
  const dx = branch.x2 - branch.x1;
  const dy = branch.y2 - branch.y1;
  const currentX = branch.x1 + dx * progress;
  const currentY = branch.y1 + dy * progress;
  const grad = ctx.createLinearGradient(branch.x1, branch.y1, currentX, currentY);
  grad.addColorStop(0, "#3a2200");
  grad.addColorStop(1, "#8b5a2b");
  ctx.strokeStyle = grad;
  ctx.lineWidth = Math.max(1, branch.width * (0.8 + progress * 0.2));
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(branch.x1, branch.y1);
  ctx.lineTo(currentX, currentY);
  ctx.stroke();
}

// === DIBUJO DE HOJAS ===
function drawHeart(x, y, size, rotation, color, alpha = 1) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(x, y);
  ctx.rotate(rotation);
  ctx.scale(size / 10, size / 10);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.bezierCurveTo(-5, -5, -10, 0, 0, 10);
  ctx.bezierCurveTo(10, 0, 5, -5, 0, 0);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.restore();
}

// === CONSTRUCCIÓN DE PATH DEL ÁRBOL ===
function buildTreePath() {
  treePath = new Path2D();
  trunkPath = new Path2D();

  branches.forEach(b => {
    const dx = b.x2 - b.x1, dy = b.y2 - b.y1;
    const length = Math.sqrt(dx*dx + dy*dy);
    if(length===0) return;
    const nx=-dy/length, ny=dx/length;
    let offset;
    if(b.depth===maxDepth) offset=Math.max(b.width/2,6);
    else if(b.depth>4) offset=Math.max(b.width/2,4);
    else offset=Math.max(b.width/2,2.5);

    const leftEdge=[], rightEdge=[];
    const samples=8;
    for(let i=0;i<=samples;i++){
      const t=i/samples;
      const px=b.x1+dx*t, py=b.y1+dy*t;
      leftEdge.push({x:px+nx*offset, y:py+ny*offset});
      rightEdge.push({x:px-nx*offset, y:py-ny*offset});
    }

    treePath.moveTo(leftEdge[0].x,leftEdge[0].y);
    leftEdge.forEach((p,i)=>i>0 && treePath.lineTo(p.x,p.y));
    for(let i=rightEdge.length-1;i>=0;i--) treePath.lineTo(rightEdge[i].x,rightEdge[i].y);
    treePath.closePath();

    if(b.depth===maxDepth){ // tronco principal
      trunkPath.moveTo(leftEdge[0].x,leftEdge[0].y);
      leftEdge.forEach((p,i)=>i>0 && trunkPath.lineTo(p.x,p.y));
      for(let i=rightEdge.length-1;i>=0;i--) trunkPath.lineTo(rightEdge[i].x,rightEdge[i].y);
      trunkPath.closePath();
    }
  });
}

// === GENERACIÓN DE HOJAS NATURALES ===
function generateNaturalLeaves() {
  leaves=[];
  const colors=["#ff5c8a","#ff6f91","#ff85a2","#ff9ecb","#ffb3d9","#ffa3b1","#ff7bbf","#ff8bb9","#ff5fa0","#ff99cc"];
  let pending=[];

  function pushLeaf(x,y,size,color,rotation,alpha=1){
    pending.push({x,y,size,color,rotation,grow:0,alpha});
  }

  function generateLeavesForBranch(b){
    const steps=3;
    for(let s=0;s<steps;s++){
      const t=(s+Math.random())/steps;
      const px=b.x1+(b.x2-b.x1)*t;
      const py=b.y1+(b.y2-b.y1)*t;

      let leafCount = b.depth>4 ? ((3+Math.floor(Math.random()*4))*2) : 1 + Math.floor(Math.random()*3);

      for(let l=0;l<leafCount;l++){
        const angle=Math.random()*Math.PI*2;
        const radius=b.width*0.7+10+Math.random()*25;
        const lx=px+Math.cos(angle)*radius;
        const ly=py-Math.sin(angle)*radius;

        let alpha=1, allow=true;
        if(ctx.isPointInPath(trunkPath,lx,ly)) allow=false;
        else if(ctx.isPointInPath(treePath,lx,ly)){
          if(Math.random()>0.1) allow=false;
          alpha=0.2+Math.random()*0.2;
        }
        if(allow) pushLeaf(lx,ly,6+Math.random()*10,colors[Math.floor(Math.random()*colors.length)],Math.random()*Math.PI,alpha);
      }
    }
  }

  // Generación de hojas: desde ramas más delgadas a gruesas
  [...thinBranches,...mainBranches].forEach(b=>generateLeavesForBranch(b));

  pending.sort((a,b)=>a.y-b.y);

  let index=0, batchSize=5, delay=25;
  function addLeavesBatch(){
    for(let i=0;i<batchSize && index<pending.length;i++,index++){
      leaves.push(pending[index]);
    }
    if(index<pending.length) setTimeout(addLeavesBatch,delay);
    else setTimeout(fillOuterBranches,500);
  }
  addLeavesBatch();

  // === Rellenar ramas externas ===
  function fillOuterBranches(){
    const extraLeaves = [];
    leaves.forEach(l=>{
      if(!thinBranches.some(b=>ctx.isPointInPath(trunkPath,l.x,l.y))){
        for(let i=0;i<2;i++){
          const angle=Math.random()*2*Math.PI;
          const dist=5+Math.random()*10;
          const nx=l.x+Math.cos(angle)*dist;
          const ny=l.y+Math.sin(angle)*dist;
          if(!ctx.isPointInPath(trunkPath,nx,ny) && !ctx.isPointInPath(treePath,nx,ny)){
            const color=colors[Math.floor(Math.random()*colors.length)];
            extraLeaves.push({x:nx,y:ny,size:6+Math.random()*10,color,rotation:Math.random()*Math.PI,grow:0,alpha:1});
          }
        }
      }
    });
    leaves.push(...extraLeaves);
    animateLeaves();
  }

  function animateLeaves(){
    leaves.forEach(l=>{
      if(l.grow<1) l.grow=Math.min(1,l.grow+0.05);
      if(l.alpha<1) l.alpha=Math.min(1,l.alpha+0.05);
    });
  }

  function drawFrame(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    branches.forEach(b=>drawBranch(b,1));
    leaves.forEach(l=>drawHeart(l.x,l.y,l.size*l.grow,l.rotation,l.color,l.alpha));
    animateLeaves();
    requestAnimationFrame(drawFrame);
  }
  drawFrame();
}

// === HOJAS CORAZÓN CON PULSO ALEATORIO ===
function generateHeartLeaves(){
  heartLeaves=[];
  const colors=["#ff5c8a","#ff6f91","#ff85a2","#ff9ecb","#ffb3d9"];
  const crownLeaves=2000;
  const scale=180;
  const centerX=baseX;
  const centerY=canvas.height*0.25;
  let pendingLeaves=[];

  for(let i=0;i<crownLeaves;i++){
    const angle=Math.random()*Math.PI*2;
    const r=1-Math.random()*0.25;
    const x=16*Math.pow(Math.sin(angle),3);
    const y=13*Math.cos(angle)-5*Math.cos(2*angle)-2*Math.cos(3*angle)-Math.cos(4*angle);
    const finalX=centerX+x*scale*r;
    const finalY=centerY+y*-scale*0.9*r;

    let alpha=1, allow=true;
    if(ctx.isPointInPath(trunkPath,finalX,finalY)) allow=false;
    else if(ctx.isPointInPath(treePath,finalX,finalY)){
      if(Math.random()>0.1) allow=false;
      alpha=0.2+Math.random()*0.2;
    }
    if(allow){
      pendingLeaves.push({
        x: finalX,
        y: finalY,
        size: 6+Math.random()*10,
        color: colors[Math.floor(Math.random()*colors.length)],
        rotation: Math.random()*Math.PI,
        grow: 0.1,
        alpha,
        pulseOffset: Math.random()*Math.PI*2
      });
    }
  }

  pendingLeaves.sort((a,b)=>a.y-b.y);
  let index=0, batchSize=400, delay=1, extraAdded=0, maxExtra=3000;

  function addBatch(){
    for(let i=0;i<batchSize && index<pendingLeaves.length;i++,index++){
      const leaf=pendingLeaves[index];
      heartLeaves.push(leaf);
      if(extraAdded<maxExtra && Math.random()<0.45){
        const childCount=1+Math.floor(Math.random()*3);
        for(let c=0;c<childCount && extraAdded<maxExtra;c++){
          const a=Math.random()*Math.PI*2;
          const dist=6+Math.random()*10;
          const child={ 
            x: leaf.x+Math.cos(a)*dist,
            y: leaf.y+Math.sin(a)*dist,
            size: leaf.size*(0.45+Math.random()*0.4),
            color: leaf.color,
            rotation: Math.random()*Math.PI,
            grow: 0.1,
            alpha: leaf.alpha,
            pulseOffset: Math.random()*Math.PI*2
          };
          heartLeaves.push(child);
          extraAdded++;
        }
      }
    }
    if(index<pendingLeaves.length) setTimeout(addBatch,delay);
    else animateHeartLeaves(); 
  }
  addBatch();

  function animateHeartLeaves(){
    function loop(){
      const t = performance.now()*0.002;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      branches.forEach(b=>drawBranch(b,1));
      leaves.forEach(l=>drawHeart(l.x,l.y,l.size*l.grow,l.rotation,l.color,l.alpha));
      heartLeaves.forEach(h=>{
        const pulse = 0.9 + 0.2*Math.sin(t + h.pulseOffset);
        drawHeart(h.x,h.y,h.size*h.grow*pulse,h.rotation,h.color,h.alpha);
      });
      requestAnimationFrame(loop);
    }
    loop();
  }
}

// === ANIMACIÓN DE HOJAS SUAVES ===
function swayLeaves() {
  let t = 0;
  function loop() {
    t += 0.02;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    branches.forEach(b=>drawBranch(b,1));
    leaves.forEach(l=>{
      const offsetX=Math.sin(t+l.x/40)*2;
      const offsetY=Math.cos(t+l.y/50)*2;
      drawHeart(l.x+offsetX,l.y+offsetY,l.size,l.rotation,l.color);
    });
    heartLeaves.forEach(h=>{
      const offsetX=Math.sin(t+h.x/25)*2.2;
      const offsetY=Math.cos(t+h.y/35)*2.2;
      drawHeart(h.x+offsetX,h.y+offsetY,h.size,h.rotation,h.color);
    });
    requestAnimationFrame(loop);
  }
  loop();
}

// === INICIALIZACIÓN ===
function start(){
  branches=[]; trunkBranches=[]; mainBranches=[]; thinBranches=[]; leaves=[]; heartLeaves=[]; startTime=null;
  generateTree(baseX,baseY,180,Math.PI/2,maxDepth,35);
  buildTreePath();
  requestAnimationFrame(drawGrowingTree);
}

function drawGrowingTree(timestamp){
  if(!startTime) startTime=timestamp;
  const elapsed=timestamp-startTime;
  const globalProgress=Math.min(elapsed/totalGrowTime,1);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const maxLevel=Math.max(...branches.map(b=>b.level));
  const levelDuration=totalGrowTime/(maxLevel+1);

  branches.forEach(branch=>{
    const branchStart=branch.level*levelDuration;
    if(elapsed>=branchStart){
      const branchProgress=Math.min((elapsed-branchStart)/(levelDuration*1.2),1);
      const eased=1-Math.pow(1-branchProgress,3);
      drawBranch(branch,eased);
    }
  });

  if(globalProgress<1) requestAnimationFrame(drawGrowingTree);
  else {
    generateNaturalLeaves();
    generateHeartLeaves();
  }
}

start();

window.addEventListener('resize',()=>{
  canvas.width=window.innerWidth;
  canvas.height=window.innerHeight;
  buildTreePath();
});
</script>
</body>
</html>
