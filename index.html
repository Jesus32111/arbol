<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Árbol con Copa Corazón Animada</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(to bottom, #87CEEB 0%, #f5e4c3 70%);
      overflow: hidden;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-end;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="tree"></canvas>

  <script>
    const canvas = document.getElementById("tree");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const baseX = canvas.width / 2;
    const baseY = canvas.height * 0.95;
    const maxDepth = 9;
    const totalGrowTime = 3500;

    let trunkBranches = [];
    let mainBranches = [];
    let thinBranches = [];
    let branches = [];
    let leaves = [];
    let heartLeaves = [];
    let leafIndex = 0;
    let startTime = null;

    // ====== GENERACIÓN DE RAMAS ======
    function generateTree(x, y, length, angle, depth, width) {
      if (depth === 0) return;
      const endX = x + length * Math.cos(angle);
      const endY = y - length * Math.sin(angle);

      const branch = { x1: x, y1: y, x2: endX, y2: endY, width, depth, level: maxDepth - depth, angle };
      branches.push(branch);
      if (depth === maxDepth) trunkBranches.push(branch);
      else if (depth > 4) mainBranches.push(branch);
      else thinBranches.push(branch);

      const nextLength = length * 0.75;
      const nextWidth = width * 0.7;
      const fixedAngle = 0.37;
      const rand = (Math.random() - 0.5) * 0.08;

      generateTree(endX, endY, nextLength, angle - fixedAngle + rand, depth - 1, nextWidth);
      generateTree(endX, endY, nextLength, angle + fixedAngle + rand, depth - 1, nextWidth);
    }

    // ====== DIBUJO DE RAMAS ======
    function drawBranch(branch, progress) {
      const dx = branch.x2 - branch.x1;
      const dy = branch.y2 - branch.y1;
      const currentX = branch.x1 + dx * progress;
      const currentY = branch.y1 + dy * progress;
      const grad = ctx.createLinearGradient(branch.x1, branch.y1, currentX, currentY);
      grad.addColorStop(0, "#3a2200");
      grad.addColorStop(1, "#8b5a2b");
      ctx.strokeStyle = grad;
      ctx.lineWidth = branch.width * (0.8 + progress * 0.2);
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(branch.x1, branch.y1);
      ctx.lineTo(currentX, currentY);
      ctx.stroke();
    }

    // ====== ANIMACIÓN DEL CRECIMIENTO DEL ÁRBOL ======
    function drawGrowingTree(timestamp) {
      if (!startTime) startTime = timestamp;
      const elapsed = timestamp - startTime;
      const globalProgress = Math.min(elapsed / totalGrowTime, 1);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const maxLevel = Math.max(...branches.map(b => b.level));
      const levelDuration = totalGrowTime / (maxLevel + 1);

      branches.forEach(branch => {
        const branchStart = branch.level * levelDuration;
        if (elapsed >= branchStart) {
          const branchProgress = Math.min((elapsed - branchStart) / (levelDuration * 1.2), 1);
          const eased = 1 - Math.pow(1 - branchProgress, 3);
          drawBranch(branch, eased);
        }
      });

      if (globalProgress < 1) {
        requestAnimationFrame(drawGrowingTree);
      } else {
        generateNaturalLeaves();
        generateHeartCrown();
        animateHeartGrowth();
      }
    }

    // ====== GENERACIÓN DE HOJAS NORMALES ======
    function generateNaturalLeaves() {
      leaves = [];

      const colors = [
        "#ff5c8a", "#ff6f91", "#ff85a2", "#ff9ecb", "#ffb3d9",
        "#ffa3b1", "#ff7bbf", "#ff8bb9", "#ff5fa0", "#ff99cc"
      ];

      for (const b of mainBranches) {
        const numLeaves = (3 + Math.floor(Math.random() * 4)) * 2;
        for (let i = 0; i < numLeaves; i++) {
          const t = Math.random() * 0.9 + 0.05;
          const px = b.x1 + (b.x2 - b.x1) * t;
          const py = b.y1 + (b.y2 - b.y1) * t;
          const side = Math.random() < 0.5 ? 1 : -1;
          const normalAngle = b.angle + side * Math.PI / 2;
          const offsetDist = b.width * 0.7 + 10 + Math.random() * 20;
          const offsetX = Math.cos(normalAngle) * offsetDist;
          const offsetY = -Math.sin(normalAngle) * offsetDist;

          const baseLeaf = {
            x: px + offsetX,
            y: py + offsetY,
            size: 6 + Math.random() * 10,
            color: colors[Math.floor(Math.random() * colors.length)],
            rotation: Math.random() * Math.PI,
          };
          leaves.push(baseLeaf);

          const clusterCount = 2 + Math.floor(Math.random() * 3);
          for (let j = 0; j < clusterCount; j++) {
            const spreadAngle = (Math.random() - 0.5) * Math.PI / 3;
            const spreadDist = 10 + Math.random() * 15;
            const cx = baseLeaf.x + Math.cos(b.angle + spreadAngle) * spreadDist;
            const cy = baseLeaf.y - Math.sin(b.angle + spreadAngle) * spreadDist;
            leaves.push({
              x: cx,
              y: cy,
              size: baseLeaf.size * (0.6 + Math.random() * 0.4),
              color: colors[Math.floor(Math.random() * colors.length)],
              rotation: Math.random() * Math.PI,
            });
          }
        }
      }

      for (const b of thinBranches) {
        if (Math.random() < 0.45) {
          const numLeaves = 1 + Math.floor(Math.random() * 3);
          for (let i = 0; i < numLeaves; i++) {
            const t = Math.random() * 0.3 + 0.6;
            const px = b.x1 + (b.x2 - b.x1) * t;
            const py = b.y1 + (b.y2 - b.y1) * t;
            const side = Math.random() < 0.5 ? 1 : -1;
            const normalAngle = b.angle + side * Math.PI / 2;
            const offsetDist = b.width * 0.4 + Math.random() * 10;
            const offsetX = Math.cos(normalAngle) * offsetDist;
            const offsetY = -Math.sin(normalAngle) * offsetDist;

            leaves.push({
              x: px + offsetX,
              y: py + offsetY,
              size: 5 + Math.random() * 8,
              color: colors[Math.floor(Math.random() * colors.length)],
              rotation: Math.random() * Math.PI,
            });
          }
        }
      }
    }

    // ====== GENERACIÓN DE COPA CORAZÓN ======
    function generateHeartCrown() {
      heartLeaves = [];
      const colors = ["#ff5c8a", "#ff6f91", "#ff85a2", "#ff9ecb", "#ffb3d9"];
      const crownLeaves = 3000;
      const scale = 180;
      const centerX = baseX;
      const centerY = canvas.height * 0.25;

      for (let i = 0; i < crownLeaves; i++) {
        const t = Math.random() * Math.PI * 2;
        const r = (1 - Math.random() * 0.25);
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
        const finalY = centerY + y * -scale * 0.9 * r;
        const finalX = centerX + x * scale * r;

        heartLeaves.push({
          x: finalX,
          y: finalY,
          size: 6 + Math.random() * 10,
          grow: 0.1,
          color: colors[Math.floor(Math.random() * colors.length)],
          rotation: Math.random() * Math.PI,
        });
      }

      // Ordenar de abajo a arriba
      heartLeaves.sort((a, b) => a.y - b.y);
    }

    // ====== DIBUJO DE HOJA ======
    function drawHeart(x, y, size, rotation, color) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);
      ctx.scale(size / 10, size / 10);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(-5, -5, -10, 0, 0, 10);
      ctx.bezierCurveTo(10, 0, 5, -5, 0, 0);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();
    }

    // ====== ANIMACIÓN DE CRECIMIENTO DE LA COPA CORAZÓN (una por una) ======
    function animateHeartGrowth() {
      let currentIndex = 0;
      const batchSize = 1; // número de hojas que aparecen por paso
      const delay = 4;     // milisegundos entre hojas (ajusta para velocidad)

      function drawFrame() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Dibuja el árbol completo
        branches.forEach(b => drawBranch(b, 1));
        leaves.forEach(l => drawHeart(l.x, l.y, l.size, l.rotation, l.color));

        // Dibuja las hojas del corazón ya generadas
        for (let i = 0; i < currentIndex && i < heartLeaves.length; i++) {
          const h = heartLeaves[i];
          if (h.grow < 1) h.grow += 0.1;
          const currentSize = h.size * Math.min(h.grow, 1);
          drawHeart(h.x, h.y, currentSize, h.rotation, h.color);
        }

        // Añadir una hoja más cada ciclo
        if (currentIndex < heartLeaves.length) {
          currentIndex += batchSize;
          setTimeout(() => requestAnimationFrame(drawFrame), delay);
        } else {
          swayLeaves();
        }
      }

      drawFrame();
    }

    // ====== MOVIMIENTO SUAVE FINAL ======
    function swayLeaves() {
      let t = 0;
      function loop() {
        t += 0.02;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        branches.forEach(b => drawBranch(b, 1));
        leaves.forEach(l => {
          const offsetX = Math.sin(t + l.x / 30) * 2;
          const offsetY = Math.cos(t + l.y / 40) * 2;
          drawHeart(l.x + offsetX, l.y + offsetY, l.size, l.rotation, l.color);
        });
        heartLeaves.forEach(h => {
          const offsetX = Math.sin(t + h.x / 25) * 2;
          const offsetY = Math.cos(t + h.y / 35) * 2;
          drawHeart(h.x + offsetX, h.y + offsetY, h.size, h.rotation, h.color);
        });
        requestAnimationFrame(loop);
      }
      loop();
    }

    // ====== INICIO ======
    function start() {
      generateTree(baseX, baseY, 180, Math.PI / 2, maxDepth, 35);
      requestAnimationFrame(drawGrowingTree);
    }

    start();
  </script>
</body>
</html>
